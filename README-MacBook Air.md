# mcp-go

简易实现的 mcp 服务框架，目前是在可以使用的地步。

一个 service 就是与一个模型的一个对话，注册一个 service 就会注册一个模型的一个对话，仅能保存一段上下文，需要注意

添加工具使用Service提供的非常粗糙的AddTool接口

## 具体使用方法：

### 一、注册 service

通过提供的 NewMCPService 接口实现，具体操作如下：

service := mcp.NewMCPService("gemma-3-12b-it", "http://localhost:1234/v1/chat/completions", "")

其中第一个参数是大模型名称，例如 deepseek-chat 、 gemma-3-12b-it 等

第二个参数是远程服务地址，特别注意的是，地址需要包含端口号以及具体的路由，例如 chat/completions 、 v1/chat/completions

第三个参数则为 api-key key本地部署没有 api-key 的就填空key

### 二、开启新对话

通过调用 service 的 NewDialogue 接口开启一个新对话，代码如下：

dialog := s.NewDialogue()

新对话可以保存上下文，但保存效果拉跨，急需加强

###  三、开始对话

通过 Dialog 的 Chat 接口与大模型进行对话，需要在对话前注册好工具，以便大模型调用。

## 新增更新：

1、更高层次的抽象，一个 service 对应一种大模型，一个 completions 对应一段对话

2、支持更多上下文存储

3、测试仅局限于本地 LMStudio 部署的大模型，未来要适配更多大模型（因为代码结构过于紧凑，后续会重构，适配更多大模型）

4、加强了上下文的存储，目前可以无限添加上下文直到内存爆炸

## 之前实现：

1、实现与大模型的对话（目前仅支持非流式调用，后期加入参数实现流式与非流式可控转换）

2、实现大模型对工具调用

3、实现上下文的存储

4、添加了对带有 api key key型的支持（目前已经通过 deepseek api 以及本地 LMStudio 部署的大模型测试）

5、优化了注册工具的方式，可以一个函数注册整个工具

## 计划实现：

1、错误检测过于简陋，后续重点加强错误检测，避免排错消耗大量精力

2、重点优化提示词，目前的提示词仍处于幼儿阶段，东拼西凑实现的功能在稳定性表现不佳

3、优化项目结构，实现在 Service 端全局添加工具，无需为 Client 重复添加工具

4、加入更多限制，例如上下文长度，对不符合的提示词加以限制，以确保系统的高效运行